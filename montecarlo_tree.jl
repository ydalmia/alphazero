import Chess.Move

import Base.lock
import Base.ReentrantLock
using Base.Threads

# conceptualize a montecarlo tree as having nodes corresponding
# to different states, and edges representing transitions between states:
# then the below tree structure stores transitions as nodes, flipping the
# common mental model. this is because alphazero is concerned with storing 
# P, W, N statistics for each transition that it explores. It is is 
# unnecessary to store state of the game, since this can be generated by 
# traversing down the tree.
mutable struct TreeNode
    isleaf::Atomic{Bool} # at the bottom of the mcts search tree?
    isready::Atomic{Bool} 
    W::Atomic{Float32} # store the children's Weight
    N::Atomic{Float32} # ... Count

    A::Union{Move, Nothing}    # UCI move to get here
    P::Float32 # ... Policy
    
    parent::Union{TreeNode, Nothing} # store pointer to parent
    children::Union{Vector{TreeNode}, Nothing} # store pointer to each child node
    # lock::Threads.Condition
    
    TreeNode() = new(
        Atomic{Bool}(true), 
        Atomic{Bool}(false),
        Atomic{Float32}(0.0), 
        Atomic{Float32}(0.0), 
        nothing, 
        0.0, 
        nothing, 
        nothing
        # ,Threads.Condition()
    )
end

function TreeNode(a::Move, p::Float32, parent::TreeNode)
    node = TreeNode() 
    node.A = a
    node.P = p
    node.parent = parent
    return node
end

# convenience wrapper that takes care of locking and unlocking
# if you use it as follows:
# with_lock(node) do
#     ... 
#     ...
# end
# with_lock(f, node::TreeNode) = lock(f, node.lock)

function children_stats(node::TreeNode)
    n = length(node.children)
    W = Array{Float32}(undef, n)
    N = Array{Float32}(undef, n)
    P = Array{Float32}(undef, n)
    A = []

    # see https://docs.julialang.org/en/v1/base/multi-threading/#Base.Threads.atomic_cas!
    for (i, child) in enumerate(node.children)
        W[i] = atomic_cas!(child.W, Float32(0.0), Float32(0.0)) # returns child.W without getting corrupted
        N[i] = atomic_cas!(child.N, Float32(0.0), Float32(0.0)) # ... N
        P[i] = child.P
        push!(A, child.A)
    end
    return W, N, P
end

function print_tree(node::TreeNode, depth=0; maxdepth=Inf)
    if depth < maxdepth
        print_node(node, depth)
        if !(node.children === nothing)
            for child in node.children
                print_tree(child, depth+1, maxdepth=maxdepth)
            end
        end
    end
end

function print_node(node::TreeNode, depth)
    if atomic_cas!(node.N, Float32(0.0), Float32(0.0)) == 0.0
        return
    end
    for i in 0:depth
        print("  ")
    end
    N = atomic_cas!(node.N, Float32(0.0), Float32(0.0))
    W = atomic_cas!(node.W, Float32(0.0), Float32(0.0))
    println("A: ", node.A, "  N: ", N, "    W: ", W)
end